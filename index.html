<!DOCTYPE html>
<html lang="fr">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Schéma interactif atelier - rails & aiguillages</title>
    <style>
      :root {
        --bg: #1d232a;
        --panel: #111418;
        --muted: #8b939b;
        --rail: #d9dfe6
      }

      body {
        margin: 0;
        background: var(--bg);
        color: #eee;
        font-family: Inter, Segoe UI, Arial, Helvetica, sans-serif
      }

      .app {
        display: flex;
        height: 100vh
      }

      .svg-wrap {
        flex: 1;
        padding: 16px
      }

      svg {
        width: 100%;
        height: 100%;
        background: linear-gradient(180deg, #111418 0%, #15181b 100%);
        border-radius: 6px
      }

      .panel {
        width: 360px;
        background: var(--panel);
        padding: 16px;
        box-sizing: border-box;
        border-left: 1px solid rgba(255, 255, 255, 0.03)
      }

      h2 {
        margin: 4px 0 12px 0;
        font-size: 16px
      }

      .section {
        margin-bottom: 12px
      }

      .btn {
        display: inline-block;
        padding: 6px 10px;
        border-radius: 6px;
        background: #2b2f33;
        color: #fff;
        text-decoration: none;
        cursor: pointer;
        font-size: 13px
      }

      .muted {
        color: var(--muted);
        font-size: 13px
      }

      .list {
        max-height: 40vh;
        overflow: auto;
        margin-top: 8px
      }

      .item {
        display: flex;
        justify-content: space-between;
        padding: 8px;
        border-radius: 6px;
        background: transparent;
        align-items: center
      }

      .item:hover {
        background: rgba(255, 255, 255, 0.02)
      }

      .status-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 8px
      }

      /* SVG styles */
      .rail {
        stroke: var(--rail);
        stroke-width: 4;
        stroke-linecap: round
      }

      .rail-gap {
        stroke: rgba(255, 255, 255, 0.06);
        stroke-dasharray: 8 6
      }

      .switch-straight {
        stroke: #f39c12;
        stroke-width: 4
      }

      .switch-divert {
        stroke: #e74c3c;
        stroke-width: 4
      }

      .bay-free {
        fill: #2ecc71
      }

      .bay-occupied {
        fill: #e74c3c
      }

      .bay-maint {
        fill: #f39c12
      }

      .train {
        fill: #3498db;
        stroke: #fff;
        stroke-width: 1
      }

      .train-label {
        fill: #fff;
        font-size: 12px;
        font-family: monospace
      }

      .clickable {
        cursor: pointer
      }

      footer {
        color: var(--muted);
        font-size: 12px;
        margin-top: 8px
      }
    </style>
  </head>

  <body>
    <div class="app">
      <div class="svg-wrap">
        <svg id="schematic" viewBox="0 0 1200 500" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <marker id="arrow" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto">
              <path d="M0,0 L6,3 L0,6 z" fill="#fff" />
            </marker>
          </defs>

          <!-- Tunnel vertical (visuel) -->
          <g id="tunnel">
            <rect x="1088" y="80" width="16" height="320" fill="#000" opacity="0.95" rx="4" />
            <text x="1100" y="72" fill="#fff" font-size="13" text-anchor="middle">Tunnel</text>
          </g>

          <!-- Optional satellite overlay (load an image from disk using the panel) -->
          <image id="satImage" x="0" y="0" width="1200" height="500" opacity="0.25" visibility="hidden"
            preserveAspectRatio="xMidYMid slice" />

          <!-- Tracks and layout grouped so we can translate/scale them to align with the overlay -->
          <g id="layout" transform="translate(0,0)">
            <!-- Tracks: three parallel tracks -->
            <!-- Coordinates: tracks run left->right between x=120 and x=1080 -->
            <g id="tracks">
              <!-- Chaque voie est composée de deux rails parallèles -->
              <!-- Voie 1 va jusqu'au tunnel (seule voie connectée au tunnel) -->
              <g id="track1">
                <!-- Voie 1 : uniquement entre le tunnel et le premier aiguillage (pivot maintenant à x=420) -->
                <line id="track1-railA" class="rail" x1="420" y1="114" x2="1088" y2="114" />
                <line id="track1-railB" class="rail" x1="420" y1="126" x2="1088" y2="126" />
              </g>
              <!-- Voie 2 : continuité à gauche de la voie 1 (même ordonnée), commence à x=120 et rejoint x=360 -->
              <g id="track2">
                <line id="track2-railA" class="rail" x1="120" y1="114" x2="420" y2="114" />
                <line id="track2-railB" class="rail" x1="120" y1="126" x2="420" y2="126" />
              </g>
              <!-- Voie 3 : en dessous et parallèle à la voie 2 -->
              <g id="track3">
                <line id="track3-railA" class="rail" x1="120" y1="194" x2="880" y2="194" />
                <line id="track3-railB" class="rail" x1="120" y1="206" x2="880" y2="206" />
              </g>
              <!-- (Removed additional sidings and branches: only V1,V2,V3 kept) -->
            </g>

            <!-- (Switch C removed; only Switch A remains) -->

            <!-- Switches: each switch has two possible visual paths (straight vs diverging) -->
            <!-- Switch A: connects track1 -> track2 around x=360 -->
            <g id="switchA" class="clickable" data-state="straight" transform="translate(0,0)">
              <!-- Aiguillage A: deux rails pour la position droite (vers voie2) -->
              <path id="A-straight-upper" d="M420,114 L360,114" class="switch-straight" visibility="visible" />
              <path id="A-straight-lower" d="M420,126 L360,126" class="switch-straight" visibility="visible" />

              <!-- Aiguillage A: deux rails pour la déviation (vers voie3) - courbe orientée ~45° vers la voie 3 -->
              <!-- smoother 45° entry: control points chosen so initial tangent is -45° and curve is gentler -->
              <path id="A-divert-upper" d="M420,114 C392,142 388,176 380,194" class="switch-divert" fill="none"
                visibility="hidden" />
              <path id="A-divert-lower" d="M420,126 C392,154 388,188 380,206" class="switch-divert" fill="none"
                visibility="hidden" />

              <circle cx="420" cy="120" r="10" fill="#fff" opacity="0.06" />
            </g>

            <!-- (Switch B removed; routing simplified to use only Switch A) -->

            <!-- Maintenance bays (quais) on the right side next to track2 -->
            <g id="bays">
              <rect id="bay1" class="bay-free clickable" x="920" y="140" width="120" height="40" rx="6" />
              <text x="980" y="168" text-anchor="middle" fill="#091018" font-size="13">Quai 1</text>

              <rect id="bay2" class="bay-free clickable" x="920" y="200" width="120" height="40" rx="6" />
              <text x="980" y="228" text-anchor="middle" fill="#091018" font-size="13">Quai 2</text>

              <rect id="bay3" class="bay-free clickable" x="920" y="260" width="120" height="40" rx="6" />
              <text x="980" y="288" text-anchor="middle" fill="#091018" font-size="13">Quai 3</text>
            </g>

            <!-- Trains: rendered dynamically -->
            <g id="trains"></g>

            <!-- Legend -->
            <g transform="translate(30,360)">
              <rect x="0" y="0" width="280" height="120" fill="#0f1315" rx="6" stroke="rgba(255,255,255,0.03)" />
              <text x="12" y="22" fill="#fff" font-size="13">Légende</text>
              <g transform="translate(12,34)">
                <rect x="0" y="0" width="14" height="8" class="bay-free" />
                <text x="22" y="8" fill="#bbb" font-size="12">Quai libre</text>
              </g>
              <g transform="translate(12,54)">
                <rect x="0" y="0" width="14" height="8" class="bay-occupied" />
                <text x="22" y="8" fill="#bbb" font-size="12">Quai occupé</text>
              </g>
              <g transform="translate(12,74)">
                <rect x="0" y="0" width="14" height="8" class="bay-maint" />
                <text x="22" y="8" fill="#bbb" font-size="12">Maintenance</text>
              </g>
            </g>

        </svg>
      </div>

      <div class="panel">
        <h2>Contrôles & état</h2>

        <div class="section">
          <div style="display:flex;gap:8px;align-items:center">
            <div class="btn" id="resetBtn">Réinitialiser positions</div>
            <div class="muted">Cliquez sur un aiguillage pour changer d'état.</div>
          </div>
        </div>

        <div class="section">
          <strong>Trains</strong>
          <div class="list" id="trainList"></div>
          <footer>Glissez un train le long d'une voie pour le déplacer.</footer>
        </div>

        <div class="section">
          <strong>Quais</strong>
          <div class="list" id="bayList"></div>
          <footer>Cliquez sur un quai pour faire défiler ses statuts.</footer>
        </div>

        <div class="section">
          <strong>Aiguillages</strong>
          <div class="list">
            <div class="item clickable" id="switchA-info">Switch A: <span id="switchA-state">droit</span></div>
          </div>
        </div>

        <div class="section">
          <strong>Alignement (photo)</strong>
          <div style="display:flex;flex-direction:column;gap:8px">
            <input type="file" id="satUpload" accept="image/*" />
            <label><input type="checkbox" id="satShow" /> Afficher la photo</label>
            <label>Opacité: <input type="range" id="satOpacity" min="0" max="1" step="0.05" value="0.25" /></label>
            <div style="display:flex;gap:6px;flex-wrap:wrap">
              <button class="btn" id="moveLeft">←</button>
              <button class="btn" id="moveRight">→</button>
              <button class="btn" id="moveUp">↑</button>
              <button class="btn" id="moveDown">↓</button>
              <button class="btn" id="moveLeftFast">←×5</button>
              <button class="btn" id="moveRightFast">→×5</button>
            </div>
            <div class="muted">Chargez la photo satellite, affichez-la, puis déplacez le plan pour l'aligner.</div>
          </div>
        </div>

      </div>
    </div>

    <script>
      // Modèle
      // indices de voie :
      // 0 = voie1 (tunnel→aiguillage),
      // 1 = voie2 (branche principale à gauche du premier aiguillage),
      // 2 = voie3 (branche en dessous)
      // 3 = voie4 (haut - siding produit par switchC)
      // 4 = voie5 (centre - continuation de voie2 via switchC)
      // 5 = voie6 (bas - déviation vers bas via switchC)
      const trackStarts = [420, 120, 120];
      const trackEnds = [1088, 420, 880];
      const trackYs = [120, 120, 200];

      const switches = {
        A: { state: 'straight', group: document.getElementById('switchA') }
      };
      // positions x des aiguillages (seuils de décision)
      const switchPositions = { A: 420 };

      const bays = [
        { id: 'bay1', name: 'Quai 1', status: 0 }, // 0 free,1 occupied,2 maint
        { id: 'bay2', name: 'Quai 2', status: 0 },
        { id: 'bay3', name: 'Quai 3', status: 0 }
      ];

      const trainsModel = [
        { id: 'T1', track: 0, x: 420 },
        { id: 'T2', track: 1, x: 240 },
        { id: 'T3', track: 2, x: 360 }
      ];

      const svg = document.getElementById('schematic');
      const trainsLayer = document.getElementById('trains');
      const satImage = document.getElementById('satImage');
      const layoutEl = document.getElementById('layout');

      // layout transform state used for aligning with the satellite image
      let layoutOffset = { x: 0, y: 0 };
      function applyLayoutTransform() {
        layoutEl.setAttribute('transform', `translate(${layoutOffset.x},${layoutOffset.y})`);
      }

      // Build smooth path from anchor points using Catmull-Rom -> Cubic Bezier conversion
      function catmullRomToBeziers(pts, tension = 1) {
        // pts: array of {x,y} anchor points (at least 3). Returns a path string with one or more C segments.
        if (!pts || pts.length < 2) return '';
        // For endpoints, duplicate first/last to create virtual neighbors
        const p = [];
        p.push(pts[0]);
        for (let i = 0; i < pts.length; i++) p.push(pts[i]);
        p.push(pts[pts.length - 1]);

        const segments = [];
        // build segments between pts[i] -> pts[i+1] for i in 0..n-2
        for (let i = 1; i < p.length - 2; i++) {
          const P0 = p[i - 1];
          const P1 = p[i];
          const P2 = p[i + 1];
          const P3 = p[i + 2];

          // control points for cubic between P1 and P2
          const cp1 = {
            x: P1.x + (P2.x - P0.x) / 6 * tension,
            y: P1.y + (P2.y - P0.y) / 6 * tension
          };
          const cp2 = {
            x: P2.x - (P3.x - P1.x) / 6 * tension,
            y: P2.y - (P3.y - P1.y) / 6 * tension
          };

          segments.push({ cp1, cp2, p2: P2 });
        }

        // build path string: move to first anchor, then add C for each segment
        let d = `M${pts[0].x},${pts[0].y}`;
        segments.forEach(s => {
          d += ` C${s.cp1.x},${s.cp1.y} ${s.cp2.x},${s.cp2.y} ${s.p2.x},${s.p2.y}`;
        });
        return d;
      }

      // Return segments (cp1, cp2, p2) for further manipulation
      function catmullRomSegments(pts, tension = 1) {
        if (!pts || pts.length < 2) return [];
        const p = [];
        p.push(pts[0]);
        for (let i = 0; i < pts.length; i++) p.push(pts[i]);
        p.push(pts[pts.length - 1]);

        const segments = [];
        for (let i = 1; i < p.length - 2; i++) {
          const P0 = p[i - 1];
          const P1 = p[i];
          const P2 = p[i + 1];
          const P3 = p[i + 2];
          const cp1 = {
            x: P1.x + (P2.x - P0.x) / 6 * tension,
            y: P1.y + (P2.y - P0.y) / 6 * tension
          };
          const cp2 = {
            x: P2.x - (P3.x - P1.x) / 6 * tension,
            y: P2.y - (P3.y - P1.y) / 6 * tension
          };
          segments.push({ cp1, cp2, p2: P2 });
        }
        return segments;
      }

      function setSwitchACurves() {
        // define three anchor points for the divert path (upper rail)
        const a0 = { x: 420, y: 114 };
        const a2 = { x: 300, y: 194 };
        // place the middle anchor horizontally exactly between start and end
        const a1 = { x: Math.round((a0.x + a2.x) / 2), y: 154 };

        // get raw segments so we can tweak control points to curve left then right
        const upperPts = [a0, a1, a2];
        const segs = catmullRomSegments(upperPts, 0.8);

        // If we have two segments (start->mid, mid->end), nudge their control X to
        // produce: first segment curves slightly to the left, second curves to the right.
        if (segs.length >= 2) {
          const leftNudge = -18; // move first segment control points left
          const rightNudge = 18; // move second segment control points right
          // first segment
          segs[0].cp1.x += leftNudge; segs[0].cp2.x += leftNudge;
          // second segment
          segs[1].cp1.x += rightNudge; segs[1].cp2.x += rightNudge;
        }

        // assemble path string
        let upperD = `M${upperPts[0].x},${upperPts[0].y}`;
        segs.forEach(s => { upperD += ` C${s.cp1.x},${s.cp1.y} ${s.cp2.x},${s.cp2.y} ${s.p2.x},${s.p2.y}`; });
        const upperPath = document.getElementById('A-divert-upper');
        if (upperPath) upperPath.setAttribute('d', upperD);

        // lower rail: same x, offset y by +12 to keep spacing constant; apply same nudges
        const b0 = { x: a0.x, y: a0.y + 12 };
        const b1 = { x: a1.x, y: a1.y + 12 };
        const b2 = { x: a2.x, y: a2.y + 12 };
        const lowerPts = [b0, b1, b2];
        const lsegs = catmullRomSegments(lowerPts, 0.8);
        if (lsegs.length >= 2) {
          const leftNudge = -18; const rightNudge = 18;
          lsegs[0].cp1.x += leftNudge; lsegs[0].cp2.x += leftNudge;
          lsegs[1].cp1.x += rightNudge; lsegs[1].cp2.x += rightNudge;
        }
        let lowerD = `M${lowerPts[0].x},${lowerPts[0].y}`;
        lsegs.forEach(s => { lowerD += ` C${s.cp1.x},${s.cp1.y} ${s.cp2.x},${s.cp2.y} ${s.p2.x},${s.p2.y}`; });
        const lowerPath = document.getElementById('A-divert-lower');
        if (lowerPath) lowerPath.setAttribute('d', lowerD);
      }

      // helper: set visibility for switch (only A supported)
      function renderSwitch(key) {
        const s = switches[key];
        if (!s) return;
        const su = document.getElementById('A-straight-upper');
        const sl = document.getElementById('A-straight-lower');
        const du = document.getElementById('A-divert-upper');
        const dl = document.getElementById('A-divert-lower');
        if (s.state === 'straight') {
          su.setAttribute('visibility', 'visible');
          sl.setAttribute('visibility', 'visible');
          du.setAttribute('visibility', 'hidden');
          dl.setAttribute('visibility', 'hidden');
        } else {
          su.setAttribute('visibility', 'hidden');
          sl.setAttribute('visibility', 'hidden');
          du.setAttribute('visibility', 'visible');
          dl.setAttribute('visibility', 'visible');
        }
        const label = document.getElementById('switch' + key + '-state');
        if (label) label.textContent = (s.state === 'straight') ? 'droit' : 'dévié';
      }

      // toggle switch (only A)
      function toggleSwitch(key) {
        if (!switches[key]) return;
        switches[key].state = (switches[key].state === 'straight') ? 'divert' : 'straight';
        renderSwitch(key);
      }

      // render bays list and colors
      function renderBays() {
        bays.forEach(b => {
          const el = document.getElementById(b.id);
          el.classList.remove('bay-free', 'bay-occupied', 'bay-maint');
          if (b.status === 0) el.classList.add('bay-free');
          if (b.status === 1) el.classList.add('bay-occupied');
          if (b.status === 2) el.classList.add('bay-maint');
        });

        const bayList = document.getElementById('bayList');
        bayList.innerHTML = '';
        bays.forEach((b, i) => {
          const div = document.createElement('div');
          div.className = 'item clickable';
          const dot = document.createElement('span');
          dot.className = 'status-dot';
          if (b.status === 0) dot.style.background = '#2ecc71';
          else if (b.status === 1) dot.style.background = '#e74c3c';
          else dot.style.background = '#f39c12';
          div.innerHTML = `<div style=\"display:flex;align-items:center\"><span class=\"status-dot\" style=\"background:${(b.status === 0 ? '#2ecc71' : (b.status === 1 ? '#e74c3c' : '#f39c12'))}\"></span><div>${b.name}</div></div><div class=\"muted\">${b.status === 0 ? 'Libre' : (b.status === 1 ? 'Occupé' : 'Maintenance')}</div>`;
          div.onclick = () => { b.status = (b.status + 1) % 3; renderBays(); };
          bayList.appendChild(div);
        });
      }

      // render trains (draggable)
      function renderTrains() {
        trainsLayer.innerHTML = '';
        trainsModel.forEach((t, idx) => {
          const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          g.setAttribute('data-id', t.id);
          const cx = t.x;
          const cy = trackYs[t.track];
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('cx', cx);
          circle.setAttribute('cy', cy);
          circle.setAttribute('r', 12);
          circle.setAttribute('class', 'train clickable');
          circle.setAttribute('fill', '#3498db');
          circle.setAttribute('stroke', '#fff');
          circle.setAttribute('stroke-width', '1');

          const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          txt.setAttribute('x', cx);
          txt.setAttribute('y', cy + 4);
          txt.setAttribute('text-anchor', 'middle');
          txt.setAttribute('class', 'train-label');
          txt.textContent = t.id;

          g.appendChild(circle);
          g.appendChild(txt);
          trainsLayer.appendChild(g);

          // drag behavior
          let dragging = false;
          let pointerId = null;

          circle.addEventListener('pointerdown', (ev) => {
            ev.preventDefault();
            dragging = true;
            pointerId = ev.pointerId;
            circle.setPointerCapture(pointerId);
          });

          circle.addEventListener('pointermove', (ev) => {
            if (!dragging || ev.pointerId !== pointerId) return;
            const pt = svg.createSVGPoint();
            pt.x = ev.clientX; pt.y = ev.clientY;
            const loc = pt.matrixTransform(svg.getScreenCTM().inverse());
            // find nearest track index based on cursor Y
            let nearestTrack = 0; let minD = Infinity;
            trackYs.forEach((y, i) => { const d = Math.abs(y - loc.y); if (d < minD) { minD = d; nearestTrack = i; } });
            // constrain x to the visible portion of the selected track
            const minX = (trackStarts && trackStarts[nearestTrack]) ? trackStarts[nearestTrack] : 120;
            const maxX = (trackEnds && trackEnds[nearestTrack]) ? trackEnds[nearestTrack] : 1088;
            const nx = Math.max(minX, Math.min(maxX, loc.x));
            // commit to model
            t.x = nx; t.track = nearestTrack;
            // update visuals
            circle.setAttribute('cx', t.x);
            circle.setAttribute('cy', trackYs[t.track]);
            txt.setAttribute('x', t.x);
            txt.setAttribute('y', trackYs[t.track] + 4);
            updateTrainList();
          });

          window.addEventListener('pointerup', (ev) => {
            if (!dragging) return;
            if (ev.pointerId !== pointerId) return;
            dragging = false;

            // Routing rule: if a train comes from voie 1 and crosses the first switch position,
            // decide the target voie depending on Switch A state:
            // - Switch A 'straight' -> voie 2 (index 1)
            // - Switch A 'divert'   -> voie 3 (index 2)
            try {
              const swAX = switchPositions.A;
              // if train was on voie 1 (or close) and its x is left of the switch, route it
              if (t.track === 0 && t.x < swAX) {
                const dest = (switches.A.state === 'straight') ? 1 : 2;
                t.track = dest;
                // constrain x to destination track limits
                const minX = (trackStarts && trackStarts[dest]) ? trackStarts[dest] : 120;
                const maxX = (trackEnds && trackEnds[dest]) ? trackEnds[dest] : 1088;
                t.x = Math.max(minX, Math.min(maxX, t.x));
                circle.setAttribute('cx', t.x);
                circle.setAttribute('cy', trackYs[t.track]);
                txt.setAttribute('x', t.x);
                txt.setAttribute('y', trackYs[t.track] + 4);
              }
              circle.releasePointerCapture(pointerId);
            } catch (e) { try { circle.releasePointerCapture(pointerId); } catch (e2) { } }

            pointerId = null;
          });

        });

        updateTrainList();
      }

      // update train list in panel
      function updateTrainList() {
        const list = document.getElementById('trainList');
        list.innerHTML = '';
        trainsModel.forEach(t => {
          const div = document.createElement('div');
          div.className = 'item';
          div.innerHTML = `<div>${t.id} <span class=\"muted\">(voie ${t.track + 1})</span></div><div class=\"muted\">x=${Math.round(t.x)}</div>`;
          list.appendChild(div);
        });
      }

      // reset positions
      document.getElementById('resetBtn').addEventListener('click', () => {
        trainsModel[0].track = 0; trainsModel[0].x = 420;
        trainsModel[1].track = 1; trainsModel[1].x = 240;
        trainsModel[2].track = 2; trainsModel[2].x = 360;
        renderTrains();
        bays.forEach(b => b.status = 0);
        renderBays();
        switches.A.state = 'straight';
        renderSwitch('A');
      });

      // Satellite overlay controls
      document.getElementById('satUpload').addEventListener('change', (ev) => {
        const f = ev.target.files && ev.target.files[0];
        if (!f) return;
        const url = URL.createObjectURL(f);
        satImage.setAttributeNS('http://www.w3.org/1999/xlink', 'href', url);
        satImage.setAttribute('href', url);
        satImage.setAttribute('visibility', document.getElementById('satShow').checked ? 'visible' : 'hidden');
      });

      document.getElementById('satShow').addEventListener('change', (ev) => {
        satImage.setAttribute('visibility', ev.target.checked ? 'visible' : 'hidden');
      });

      document.getElementById('satOpacity').addEventListener('input', (ev) => {
        satImage.setAttribute('opacity', ev.target.value);
      });

      // move buttons
      document.getElementById('moveLeft').addEventListener('click', () => { layoutOffset.x -= 1; applyLayoutTransform(); });
      document.getElementById('moveRight').addEventListener('click', () => { layoutOffset.x += 1; applyLayoutTransform(); });
      document.getElementById('moveUp').addEventListener('click', () => { layoutOffset.y -= 1; applyLayoutTransform(); });
      document.getElementById('moveDown').addEventListener('click', () => { layoutOffset.y += 1; applyLayoutTransform(); });
      document.getElementById('moveLeftFast').addEventListener('click', () => { layoutOffset.x -= 5; applyLayoutTransform(); });
      document.getElementById('moveRightFast').addEventListener('click', () => { layoutOffset.x += 5; applyLayoutTransform(); });

      // wire switches clickable (only A)
      document.getElementById('switchA').addEventListener('click', () => { toggleSwitch('A'); });
      document.getElementById('switchA-info').addEventListener('click', () => { toggleSwitch('A'); });

      // bays click handlers
      bays.forEach(b => {
        document.getElementById(b.id).addEventListener('click', () => { b.status = (b.status + 1) % 3; renderBays(); });
      });

      // initial render
      // compute and set A divert curves from three anchor points
      setSwitchACurves();
      renderSwitch('A'); renderBays(); renderTrains();

      // Expose a few helpers to console for debugging
      window.__atelier = { trainsModel, bays, switches, renderTrains, renderBays };
    </script>
  </body>

</html>